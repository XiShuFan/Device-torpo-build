# Device-torpo-build
设计拓扑生成算法，将设备连接情况输出到json文件，用ECharts画布进行展示





## 拓扑拼接算法

参考以下拓扑图：

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/oms-route.png)

给出一个简化的拓扑图例子：

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/初始图.png)



### 方向

我们只考虑从左到右的方向（反方向转换成正方向），在计算出坐标之后再考虑绘图时实际的正反方向。

所以上面这个图是一个有向无环图。

起始节点：

- 3，1，2，8，9

目的节点：

- 30，31，33



### 临时终点

定义**入度大于等于2**或者**出度大于等于2**的点为临时终点，在图中用橙色标注如下：

临时终点在广度优先遍历时起作用。

临时终点在调整x坐标时起作用。

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/标出临时终点.png)



### 节点的level

定义：起始节点的level为0，**经过Mux时减一，经过DMux时加一**。

当多次遍历到同一个节点，并且level不同时，取最小值。



### 节点的X坐标

定义：起始节点的X坐标为0，经过一个节点，加一。



### 拓扑建立过程

在图中，使用二元组**(x, level)**记录每个节点的信息。

从起始端口开始广度优先遍历

#### 第一步

起始端口初始化x和level，入队

> 队列：3，1，2，8，9

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第一步2.png)



#### 第二步

队列中的节点全部向后遍历一跳，这时，会发现1，2节点遍历到了临时终点4，8节点遍历到了临时终点10，我们如下操作：

- 当遍历到临时终点时，**不入队**，**放入一个临时终点队列**，起到“终点”的作用
- 当队列中没有节点时，取临时终点的首节点入队

所以第二步过后，队列如下：

> 队列：5，11

> 临时终点队列：4，10

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第二步2.png)

#### 第三步

队列中还有节点，继续遍历，5节点的下一节点是临时终点7，11的下一跳是12

> 队列：空

> 临时终点队列：4，10，7，12

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第三步2.png)



#### 第四步

这时候队列空了，取临时终点队列的首节点4入队，继续遍历后，4节点的下一跳是6和10

由于10已经被达到过了，所以只更新x和level

4节点的x是1，和它的上游节点1，2的x坐标都相差1，所以不需要改动

> 队列：6

> 临时终点队列：10，7，12

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第四步2.png)



#### 第五步

6的下一跳是临时终点7，由于7已经被到达过了，所以只更新x和level值

x取最大值，level取最小值

> 队列：空

> 临时终点队列：10，7，12

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第五步2.png)

#### 第六步

取出10，继续遍历，10的下一跳12，只更新x和level

这个时候发现10的x坐标和它的上游节点8的x坐标相差不是1，所以需要更新坐标值

- 这时候需要靠level来更新坐标，我们的目标是找到和10的level相等的节点，但是在这里是找不到的，所以直接遍历到终点即可
- 10节点和上游节点的x相差2，也就是说有1的误差（正常情况下，10和8的坐标相差应该只有1），记Δx=1

- 从10往上游节点走，到了8，也就是终点
- 所以这一段上的每一个节点的x坐标都需要加上一个偏差，这个偏差计算公式如下

$$
δ=\frac{Δx}{2}
$$

- 由于终点8和10之间没有其他节点，所以不需要更新

> 队列：空

> 临时终点队列：7，12

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第六步2.png)

#### 第七步

取出7，往下遍历到13，只更新x和level

这是也发现7的上游节点5的坐标相差不是1，Δx=1

- 从7向上游遍历，找到level同为-2的节点或者终点
- 找到了终点3
- 所以3和7之间的所有节点的坐标都要加上0.5，5节点的横坐标变成1.5
- **注：3和7之间的所有节点的横坐标的更新也可以通过另一个广度优先算法实现**

> 队列：空

> 临时终点队列：12，13

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第七步.png)

#### 第八步

取出12节点，往下遍历到13，只更新x和level

同理，这时发现13的上游节点11，横坐标相差2，进行坐标更新

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第八步.png)

> 队列：空

> 临时终点队列：13



#### 第九步

取出13节点，遍历到14

> 队列：14

> 临时终点队列：空

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第九步.png)

#### 第十步

14遍历到15和20，20遍历到21，这两步之后结果如下：

> 队列：空

> 临时终点队列：15，21

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十步.png)

#### 第十一步

取出15，进行遍历，直到19节点（中间过程省略）

> 队列：空

> 临时终点队列：21，19

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十一步.png)

#### 第十二步

取出21节点，进行遍历，直到27节点

> 队列：空

> 临时终点队列：19，27

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十二步.png)

#### 第十三步

取出19节点，遍历到28

发现此时19的上游节点16的横坐标相差2，需要进行更新

- 从19开始，往上有节点16遍历
- 找到了相同level的15节点，所以15和19的中间节点16需要修改x坐标

> 队列：空

> 临时终点队列：27，28

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十三步.png)

#### 第十四步

取出27节点，遍历到28

此时发现上游节点23的x坐标相差2

- 从27开始，往上游23节点遍历
- 找到相同level的21节点，所以21和27之间的节点22，23需要修改x坐标

> 队列：空

> 临时终点队列：28

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十四步.png)

#### 第十五步

取出28节点，往下遍历到29和32

此时发现28节点和上游节点19的x坐标相差3

- 从28开始，往上游19节点遍历
- 找到了相同level的14节点
- 所以需要更新14和28之间的15，16，17，18，19节点的坐标

> 队列：32

> 临时终点队列：29

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/第十五步.png)

#### 最后一步

直接把剩下的都遍历完

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/最后一步.png)



## 最终结果

根据x坐标调整的节点拓扑如下：

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/最终结果2.png)



### 节点的Y坐标

上述拓扑算法只确定了X坐标，没有确定Y坐标。因此设计另一套确定Y坐标的算法，尽力使拓扑图美观。

按照一般的拓扑图格式，13节点是ITL-1，7节点是ITL-2，12节点是ITL-3，14节点是OLP-3，15节点是OLP-1，21节点是OLP-2。

所以，我们从13节点向左生成Y坐标，从14节点向右生成Y坐标。

方法和生成X坐标类似，也需要用到临时终点，但是我们给Y坐标的是一个范围值。

**注**：y坐标重叠的问题并没有很好地解决。



### 算法错误更新

#### X坐标错误

我们在更新X坐标的时候，可能会出现上游节点的x坐标还没有计算出来（还是默认值0）的时候，就进行更新，这样就会出错，例子如下：

> 产生问题的原因是：一条BFS路径走得更快

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/1626317353(1).jpg)

如何解决：我们是通过MUX的上游判断来更新，所以需要记录上游是否都到达，所以开一个map，记录每个MUX的到达次数，如果到达次数等于上游的分支次数，那么就可以开始更新了，否则就需要继续等待。等待的方法就是从队首放到队尾。





### 效果展示

经检查，所有的拓扑图都可以按照**左右对称**的方式展示出来。

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/1627370048(1).jpg)

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/1627370237(1).jpg)

![](https://cdn.jsdelivr.net/gh/XiShuFan/picRepo//img/1627370266(1).jpg)



## 仓库说明

文件夹`BuildTorpoJson`下是生成拓扑json的java源代码，文件夹`show`下是生成结果以及前端展示界面。

为了方便地在本地观察拓扑效果，避免跨域问题，可以使用VSCode提供的Live Server 插件。无需创建一个服务器。
